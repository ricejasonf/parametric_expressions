<html>
<head>
<link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/routeros.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<style>
body {
    background-color:#8121ff;
    color:white;
}
</style>
</head>
<body>
<h1>Declaration Syntax</h1>
<pre><code class="cpp">
using add(x, y) = x + y;
</code></pre>

<pre><code class="cpp">
using add(constexpr x,
          constexpr y) = x + y;
</code></pre>

<h1>Parameter Kinds</h1>

<pre><code class="cpp">
  using add(a, b) = a + b;

  int i = 40;
  int x = add(i++, 2);

  // the same as

  int i = 40;
  int x = ({
    auto& a = i++;
    auto&& b = 2;
    a + b; // result of expression
  });
</code></pre>

<pre><code class="cpp">
  using add(constexpr a,
            constexpr b) = a + b;

  constexpr int i = 40;
  constexpr int x = add(i, 2);

  // the same as

  constexpr int i = 40;
  constexpr int x = ({
    constexpr auto a = i;
    constexpr auto b = 2;
    a + b; // result of expression
  });
</code></pre>

<pre><code class="cpp">
  using add(using a,
            using b) = a + b;

  int i = 40;
  int x = add(i, 2);

  // the same as

  int i = 40;
  int x = i + 2;
</code></pre>

<pre><code class="cpp">
  struct foo {
    int x;
    using bar(this self, x) = self.x + x;
  };

  struct foo {
    int x;
    using bar(using this self, x) = self.x + x;
  };

  struct foo {
    int x;
    using bar(constexpr this self, x) = self.x + x;
  };

  struct foo {
    int x;
    using bar(this constexpr self, x) = self.x + x;
  };

  struct foo {
    static using bar(x, y) = x + y;
  };
</code></pre>

<h1>Operator Overloading</h1>

<pre><code class="cpp">
  namespace mine {
    using foo(x, y) = hana::equal(fwd(x), fwd(y));
  }

  struct id_fn {
    using operator()(this self, x) = x;
  };

  int x = id_fn{}(42);

  struct id_fn {
    static using operator()(x) = x;
  };

  int x = id_fn{}(42);
</code></pre>

<h1>Transparent Context</h1>
<pre><code class="cpp">
  // (Taken from http://ldionne.com/P1221-presentation/#/9)
  // Test transparent AST node

  #include <cassert>
  #include <type_traits>

  using twice(using x) = return x * 2;

  template &lt;typename T,
            typename = decltype(twice(std::declval<T>()))&gt;
  auto foo(T x) {
    return twice(x);
  }

  auto foo(...) {
    return "not implemented";
  }

  struct blah { };

  int main() {
    constexpr auto x = twice(1);
    assert(foo(3) == 6); // OK
    assert(foo(blah{}) == "not implemented"); // OK, would normally be an error
  }
</code></pre>

<script>
document.addEventListener('DOMContentLoaded', (event) => {
  document.querySelectorAll('pre code').forEach((block) => {
    hljs.highlightBlock(block);
  });
});
</script>
</body>
</html>
